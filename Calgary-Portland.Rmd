---
title: "Predict Inundation in Portland Using Inundation Model Trained on Calgary"
author: "Junyi Yang, Yiming Shao"
date: "3/23/2025"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    code_folding: hide
editor_options: 
  markdown: 
    wrap: 72
---

# 1. Introduction

Flooding is one of the most costly and catastrophic natural hazards,
especially in urban environments where impervious surfaces and
population density increase exposure. Inundation risks are also
projected to rise due to climate change, continued urban development,
and aging infrastructure. In light of these risks, predictive modelling
of flooding inundation can inform strategic planning and identify
vulnerable area in Portland in advance.\

This project develops a spatial logistic regression model using the 2013
Calgary flood as a reference event. The model includes geographical and
environmental variables - including elevation, slope, flow accumulation,
land cover, and distance to rivers - to estimate the probability of
flood inundation across a city. These variables were derived using
GIS-based pre-processing and extracted at the grid-cell level for
analysis in R. The model was trained on 70% of Calgary data and tested
on the remaining 30%. It was then applied to a comparable city -
Portland, Oregon to evaluate flood inundation probability.\

Key results indicate that all variables were statistically significant,
and the model performed well in predicting inundated and non-inundated
areas, especially good at identifying non-inundated zones, but with some
underestimation of flood zones. The confusion matrix and ROC analysis
confirmed the model's ability to generalize beyond the training data.
When applied to Portland, the model successfully identifies high
inundation probability areas.

# 2. Setup

```{r setup, include=FALSE, warning = FALSE, message = FALSE}

knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE
)

knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
library(knitr)
library(terra)
library(sf)
library(dplyr)
library(ggplot2)
library(viridis)
library(raster)
library(scales)
library(patchwork)
```

```{r libraries, warning = FALSE, message = FALSE}
library(caret)
library(pscl)
library(plotROC)
library(pROC)
library(sf)
library(tidyverse)
library(kableExtra)
library(tigris)
```

## 2.1 Load spatial data, including city boundary and variables

To develop the model, spatial datasets are loaded for both Calgary and
Portland, including Elevation, Slope, Flow Accumulation, Distance to
River, and Land Cover (Developed, Forest, and Grassland).\
The coordinate systems used in this study is:\
GS_1984_Web_Mercator_Auxiliary_Sphere

```{r load-data, include=FALSE, warning = FALSE, message = FALSE, results = "hide"}

# Calgary data

# Load raster layers
Elevation_cal <- raster("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Calgary/Elevation/cal_elevation.tif")
Dis_River_cal <- raster("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Calgary/Distance%20to%20River/dis_river_2.tif")
Flow_accu_cal <- raster("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Calgary/Flow%20Accumulation/flow_acc_cal.tif")
Slope_cal     <- raster("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Calgary/Slope/slope_cal.tif")

# Load vector layers
developed_cal <- st_read("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Calgary/shapefile_city_cover/Developed.geojson")
forest_cal    <- st_read("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Calgary/shapefile_city_cover/Forest.geojson")
grassland_cal <- st_read("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Calgary/shapefile_city_cover/Grassland.geojson")
city_boundary_cal  <- st_read("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Calgary/shapefile_city_cover/calgary_city_boundary.geojson")
# fishnet
fishnet_cal <- st_read("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Calgary/Fishnet_Calgary/Calgary_fishnet.geojson")


# Portland data

# Load raster layers
Elevation_por <- raster("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Portland/original/dem/dem_mercator_clip.tif")
Dis_River_por <- raster("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Portland/original/disWater/dis_water_clip.tif")
Flow_accu_por <- raster("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Portland/original/flow/flow_accu.tif")
Slope_por     <- raster("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Portland/original/slope/slope_clip.tif")

# Load vector layers
developed_por <- st_read("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Portland/original/developed/develop.geojson")
forest_por    <- st_read("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Portland/original/forest/forest.geojson")
grassland_por <- st_read("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Portland/original/grassland/grassland.geojson")
city_boundary_por  <- st_read("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Portland/fishnet/fishnetBoundary.geojson")
# fishnet
fishnet_por <- st_read("https://raw.githubusercontent.com/junyi2022/Calgary-Portland-Inundation/main/data/Portland/fishnet/fishnet200m_withvalue.geojson")

# Extract Inundation Data
# 2013 Calgary flood inundation values for each fishnet grid centroid. Converts raster data into a binary target variable (`inundated_binary`). 

inundation_raster <- raster("/Users/1m/Documents/Calgary-Portland-Inundation/data/Calgary/midTermProject_Data/inundation")
fishnet_centroids <- st_centroid(fishnet_cal)
fishnet_cal$inundated <- raster::extract(inundation_raster, fishnet_centroids)
fishnet_cal <- fishnet_cal %>%
  mutate(inundated_binary = ifelse(!is.na(inundated) & inundated != 0, 1, 0))

```

## 2.2 Normalize elevation and flow accumulation data in two cities

Why elevation scale to 0-300: the Calgary and Portland elevation range
is xxx and xxx, about 300 difference.\
Wht scale elevation\
- yimi:calgary elevation 967 to 1290m

why scale flow accumulation\
- yimi: when applying the model across different regions with varying
hydrologic networks, it is important to normalized the these continuous
variables, so that the model avoids being dominated by large-magnitude
predictors and maintains consistent variable influence between Calgary
and Portland.

```{r}
fishnet_cal$Nor_Elevation <- rescale(fishnet_cal$Elevation, to = c(0, 300))
fishnet_cal$Nor_Flow_accu <- rescale(fishnet_cal$Flow_accu, to = c(0, 10000))

fishnet_por$Nor_Elevation <- rescale(fishnet_por$Elevation, to = c(0, 300))
fishnet_por$Nor_Flow_accu <- rescale(fishnet_por$Flow_accu, to = c(0, 10000))
```

# 3. Exploratory analysis

## 3.1. Maps

### 3.1.1 Elevation

```{r}
# -------Plotting Elevation--------
names(Elevation_cal) <- "elevation"
elev_df <- as.data.frame(Elevation_cal, xy = TRUE, na.rm = TRUE)

ggplot(elev_df, aes(x = x, y = y, fill = elevation)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Elevation (m)", option = "viridis") +
  coord_equal() +
  labs(
    title = "Elevation Map of Calgary Area",
    x = "Easting (meters)",   # more accurate label
    y = "Northing (meters)"
  ) +
  theme_minimal()

# ----------Plotting Slope----------
names(Slope_cal) <- "slope"
city_boundary_proj <- st_transform(city_boundary_cal, crs(Slope_cal))
slope_masked <- mask(crop(Slope_cal, vect(city_boundary_proj)), vect(city_boundary_proj))
slope_df <- as.data.frame(slope_masked, xy = TRUE, na.rm = TRUE)
ggplot(slope_df, aes(x = x, y = y, fill = slope)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Slope (degrees)", option = "magma", direction = -1) +
  coord_equal() +
  labs(
    title = "Slope Map of Calgary ",
    x = "Easting (meters)",
    y = "Northing (meters)"
  ) +
  theme_minimal()

# --------Plotting distance to river----------
names(Dis_River_cal) <- "distance_to_river"
city_boundary_proj <- st_transform(city_boundary, crs(Dis_River_cal))
river_masked <- mask(crop(Dis_River_cal, vect(city_boundary_proj)), vect(city_boundary_proj))
river_df <- as.data.frame(river_masked, xy = TRUE, na.rm = TRUE)
colnames(river_df)[3] <- "distance_to_river"
ggplot(river_df, aes(x = x, y = y, fill = distance_to_river)) +
  geom_raster() +
  scale_fill_viridis_c(
    name = "Distance to River (m)",
    option = "plasma",
    direction = -1
  ) +
  coord_equal() +
  labs(
    title = "Updated Distance to River",
    x = "Easting (meters)",
    y = "Northing (meters)"
  ) +
  theme_minimal()

# --------Plotting flow accumulation--------
names(Flow_accu_cal) <- "flow_acc"
city_boundary_proj <- st_transform(city_boundary, crs(Flow_accu_cal))
flow_masked <- mask(crop(Flow_accu_cal, vect(city_boundary_proj)), vect(city_boundary_proj))
flow_df <- as.data.frame(flow_masked, xy = TRUE, na.rm = TRUE)
colnames(flow_df)[3] <- "flow_acc"

flow_mean <- mean(flow_df$flow_acc, na.rm = TRUE)
flow_sd   <- sd(flow_df$flow_acc, na.rm = TRUE)
lower <- flow_mean - 2 * flow_sd
upper <- flow_mean + 2 * flow_sd

flow_df <- flow_df %>%
  mutate(flow_stretched = pmax(pmin(flow_acc, upper), lower))
ggplot(flow_df, aes(x = x, y = y, fill = flow_stretched)) +
  geom_raster() +
  scale_fill_viridis_c(
    name = "Flow Accumulation (±2 SD)",
    option = "inferno"
  ) +
  coord_equal() +
  labs(
    title = "Flow Accumulation in Calgary (Stretched by ±2 SD)",
    x = "Easting (meters)",
    y = "Northing (meters)"
  ) +
  theme_minimal()

# -------Plotting land cover by grassland, developed, and forest------
target_crs <- crs(Elevation_cal)
developed_area  <- st_transform(developed_area, target_crs)
grassland_area  <- st_transform(grassland_area, target_crs)
forest_area     <- st_transform(forest_area, target_crs)
developed_area  <- st_zm(developed_area)
grassland_area  <- st_zm(grassland_area)
forest_area     <- st_zm(forest_area)
developed_area  <- developed_area  %>% select(geometry) %>% mutate(landcover = "Developed")
grassland_area  <- grassland_area  %>% select(geometry) %>% mutate(landcover = "Grassland")
forest_area     <- forest_area     %>% select(geometry) %>% mutate(landcover = "Forest")
landcover_plot <- rbind(developed_area, grassland_area, forest_area)

ggplot() +
  geom_sf(data = landcover_plot, aes(fill = landcover), color = NA, alpha = 0.8) +
  scale_fill_manual(
    values = c(
      "Developed" = "#e41a1c",
      "Grassland" = "#4daf4a",
      "Forest"    = "#377eb8"
    ),
    name = "Land Cover Type"
  ) +
  coord_sf() +
  labs(
    title = "Land Cover Map of Calgary",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    legend.title = element_text(size = 11, face = "bold"),
    legend.text = element_text(size = 10)
  )
```

Let's plot the sf object of our protected lands on top of our counties.
We give the shape some color and transparency (alpha).

```{r first_plot, warning = FALSE, message = FALSE}
ggplot() +
  #geom_sf(data = fishnet_boundary_Portland)+
  geom_sf(data = developed_por, 
          fill = "blue", 
          color = "blue",
          alpha = 0.6) +
  labs(title="Water Area in Portland") +
  theme_void()
```

```{r}
# Convert raster to data frame
dem_df_Portland <- as.data.frame(dem_Portland, xy = TRUE)
colnames(dem_df_Portland) <- c("x", "y", "elevation")

# Create plot
ggplot() +
  geom_raster(data = dem_df_Portland, aes(x = x, y = y, fill = elevation)) +
  scale_fill_gradientn(colors = terrain.colors(100)) +
  ggtitle("DEM Visualization") +
  coord_equal()  +
  theme_void()
```


# 4. Exploratory Data Analysis (EDA)

## 4.1 Grouped Bar Plot

Compares the mean of each predictor between flooded and non-flooded cells. Useful for identifying variables that may distinguish 0 vs. 1.

```{r}
# Reshape fishnet data into long format for group mean calculation
floodEDA <- fishnet_cal %>%
  as.data.frame() %>%
  dplyr::select(inundated_binary, Elevation, Dis_River, Slope, Flow_accu, Developed, Forest, Grassland) %>%
  pivot_longer(cols = -inundated_binary, names_to = "variable", values_to = "value")

# Plot grouped bar charts of mean values
floodEDA %>%
  group_by(inundated_binary, variable) %>%
  summarize(mean = mean(value, na.rm = TRUE), .groups = "drop") %>%
  ggplot(aes(x = as.factor(inundated_binary), y = mean, fill = as.factor(inundated_binary))) +
  geom_bar(stat = "identity") +
  facet_wrap(~variable, scales = "free") +
  scale_fill_manual(values = c("dark blue", "dark green"),
                    labels = c("Not Inundated", "Inundated"),
                    name = "") +
  labs(title = "Mean Predictor Values by Inundation Status",
       x = "Inundation Status", 
       y = "Mean Predictor Value")
```

## 4.2 Violin Plot

Shows distribution shape and spread of each variable across classes. Helps detect skewness or overlap.

```{r}
floodEDA_violin <- floodEDA
# Violin plot to show full variable distribution by binary outcome
ggplot(floodEDA_violin) + 
  geom_violin(aes(x = as.factor(inundated_binary), y = value, fill = as.factor(inundated_binary)), alpha = 0.7) + 
  facet_wrap(~variable, scales = "free") +
  scale_fill_manual(values = c("dark blue", "dark green"),
                    labels = c("Not Inundated", "Inundated"),
                    name = "") +
  labs(title = "Distribution of Predictor Variables by Inundation Status",
       x = "Inundation Status", 
       y = "Value") +
  theme_bw()
```

# 5. Model Training

## 5.1 Splitting the Data into Training and Testing Sets

In our model, we used 70% of the Calgary fishnet grid cells as the training set to build the logistic regression model and the remaining 30% as the test set to evaluate its performance. This ensures that we can further assess how well our model generalizes to new, unseen data.

```{r}
set.seed(3456)
trainIndex <- createDataPartition(fishnet_cal$inundated_binary, p = .70,
                                  list = FALSE,
                                  times = 1)
fishnetTrain <- fishnet_cal[trainIndex, ]
fishnetTest <- fishnet_cal[-trainIndex, ]
```

## 5.2 Building the Logistic Regression Model

The logistic regression model estimates the probability of flood inundation in Calgary based on several variables, including elevation (normalized), distance to river, slope, flow accumulation(normalized), and land cover types (developed, forest, grassland). The model was fitted using the glm() function with a binomial logit link.

```{r}
# Logistic regression model using normalized values
floodModel <- glm(inundated_binary ~ Nor_Elevation + Dis_River + Slope + Nor_Flow_accu + 
                                  Developed + Forest + Grassland, 
                  family = binomial(link = "logit"), 
                  data = fishnetTrain %>%
                         as.data.frame() %>%
                         dplyr::select(-geometry)) 
summary(floodModel)
```

The result indicate that all variables included in the model are statistically significant, with p-values below 0.01, suggesting strong associations with flood risk. In addition, elevation, distance to river, slope, developed land, and grassland all have negative coefficients, meaning they are associated with decreased odds of inundation. In contrast, flow accumulation and forest area are positively associated with higher flood likelihood.

# 6. Model validation

## 6.1 Density of Predicted Flood Risk by Inundation Outcome

```{r}
classProbs <- predict(floodModel, newdata = fishnetTest, type = "response")
hist(classProbs, main = "Distribution of Predicted Flood Probabilities",
     xlab = "Predicted Probability", col = "skyblue")
```

The overall distribution of predicted flood probabilities generated by the logistic regression model for the test set. Most of the predicted probabilities are clustered near zero, indicating that the model classifies the majority of cells as not inundated.

```{r}
testProbs <- data.frame(obs = fishnetTest$inundated_binary, pred = classProbs)
# Density plot
ggplot(testProbs, aes(x = pred, fill = as.factor(obs))) + 
  geom_density(alpha=0.6) +
  facet_grid(obs ~ .) + 
  xlab("Predicted Probability of Inundation") +
  ylab("Density") +
  geom_vline(xintercept = 0.5, linetype="dashed") +
  scale_fill_manual(values = c("dark blue", "dark green"),
                    labels = c("Not Inundated", "Inundated"),
                    name = "Observed") +
  ggtitle("Predicted Probability vs. Actual Flood Inundation") +
  theme_bw()
```

This density plot shows the distribution of predicted flood probabilities generated by the logistic regression model, separated by the actual observed inundation status (0 = Not Inundated, 1 = Inundated). It reveals that non-flooded cells cluster around low probabilities, while flooded cells have a broader spread, though many still fall below 0.5. Together, these plots suggest the model is good at identifying non-inundated areas but less confident for flooded zones, with some overlap between classes.

## 6.2 Confusion metrics

```{r}
testProbs$predClass <- ifelse(testProbs$pred > 0.2, 1, 0)
confusionMatrix(reference = as.factor(testProbs$obs),
                data = as.factor(testProbs$predClass),
                positive = "1")
```

For this model, a threshold of 0.2 was chosen to classify areas as flood-inundated. This lower threshold was selected to prioritize sensitivity. While this increases the chance of false positives (predicting flood where none occurs), it reduces the risk of missing true flood zones, which is important in disaster preparation and planning.

The model achieved an overall accuracy of 91.47%. The sensitivity (true positive) is 44.34%, indicating that the model correctly identified approximately 44% of truly inundated locations. In contrast, the specificity is 96.03%, showing its strong performance in correctly identifying non-inundated areas. The Kappa statistic of 0.43 suggests moderate agreement between predicted and actual classes beyond chance.

### 6.2.1 Interpretation of Confusion Matrix Outcomes

True Positive (TP): The model correctly predicted an area as inundated, and it was actually inundated.\
False Positive (FP): The model predicted an area as inundated, but it was not actually inundated.\
True Negative (TN): The model correctly predicted an area as not inundated, and it was truly not inundated.\
False Negative (FN): The model predicted an area as not inundated, but it was actually inundated.

```{r}
# Table of confusion counts
conf_mat <- confusionMatrix(reference = as.factor(testProbs$obs),
                            data = as.factor(testProbs$predClass),
                            positive = "1")
# Table of confusion counts
cm_table <- conf_mat$table
TN <- cm_table[1,1]; FP <- cm_table[2,1]
FN <- cm_table[1,2]; TP <- cm_table[2,2]

confusion_counts <- data.frame(
  Outcome = c("True Positive (TP)", "False Positive (FP)", 
              "True Negative (TN)", "False Negative (FN)"),
  Count = c(TP, FP, TN, FN)
)

knitr::kable(confusion_counts, caption = "Confusion Matrix Breakdown", align = "l")
```

### 6.2.2 Confusion Matrix Map: Spatial Distribution of Model Predictions

The map visualizes the spatial distribution of model prediction outcomes for each fishnet cell in Calgary. This full-area map is based on predictions using a threshold of 0.2, providing insights into where the model is performing well and where it is making errors.

```{r}
fishnet_cal$predicted_prob <- predict(floodModel, newdata = fishnet_cal, type = "response")
fishnet_cal$predicted_class <- ifelse(fishnet_cal$predicted_prob > 0.2, 1, 0)
fishnet_cal <- fishnet_cal %>%
  mutate(confusion_type = case_when(
    inundated_binary == 1 & predicted_class == 1 ~ "True Positive",
    inundated_binary == 0 & predicted_class == 0 ~ "True Negative",
    inundated_binary == 0 & predicted_class == 1 ~ "False Positive",
    inundated_binary == 1 & predicted_class == 0 ~ "False Negative",
    TRUE ~ NA_character_
  ))
confusion_colors <- c(
  "True Positive" = "#762a83",    
  "True Negative" = "#f0f0f0",   
  "False Positive" = "#0571b0",   
  "False Negative" = "#ca0020"  
)

# Map
ggplot(data = fishnet_cal) +
  geom_sf(aes(fill = confusion_type), color = NA, size = 0.01) +
  scale_fill_manual(values = confusion_colors, name = "Results") +
  labs(title = "Confusion Metrics",
       subtitle = "Full Spatial Classification Based") +
  theme_void() +
  theme(legend.position = "right",
        plot.title = element_text(size = 14, face = "bold"))
```

Purple is the area correctly identified as inundated, while light gray area indicates correct non-flood predictions. Blue shows where the model predicted flooding but no inundation occurred, and red is missed flood areas that were incorrectly classified as dry. The map shows that many True Positives align with river-adjacent zones, but there are still notable clusters of False Negatives, highlighting areas where the model underestimates the risk — a key concern for flood inundation risk mitigation.


## 6.3 Receiver Operating Characteristic (ROC) Curve & Area Under the Curve (AUC)

The ROC curve visualizes the model’s ability to distinguish between flooded (positive) and non-flooded (negative) areas across all classification thresholds.

```{r}
ggplot(testProbs, aes(d = obs, m = pred)) + 
  geom_roc(n.cuts = 50, labels = FALSE, color = "blue") + 
  style_roc(theme = theme_grey) +
  geom_abline(slope = 1, intercept = 0, size = 1.2, color = 'grey', linetype = "dashed") +
  labs(title = "ROC Curve of Flood Inundation Model",
       x = "False Positive Rate (1 - Specificity)",
       y = "True Positive Rate (Sensitivity)") +
  theme_minimal()

auc_value <- auc(testProbs$obs, testProbs$pred)
auc_value
```

The ROC curvature and distance from the diagonal "random guess" line indicate strong discriminatory power. The blue line shows high sensitivity (true positive rate) at low false positive rates, suggesting that the model performs well in identifying flooded areas. The AUC is 0.8059, reflecting a good discriminatory ability.

## 6.4 Cross-Validation

To assess the model’s generalizability and reduce overfitting risk, we applied 5-fold cross-validation. This method involves splitting the training dataset into five equal parts (folds). The model is trained on four of the folds and validated on the fifth.

```{r}
# Set up cross-validation control
train_control <- trainControl(method = "cv", number = 5)  # 5-fold cross-validation

# Fit logistic regression model with normalized inputs
floodModel_cv <- train(as.factor(inundated_binary) ~ Nor_Elevation + Dis_River + Slope + Nor_Flow_accu + Developed + Forest + Grassland,
                       data = fishnetTrain %>% as.data.frame() %>% dplyr::select(-geometry),  # disambiguate select()
                       method = "glm",
                       family = "binomial",
                       trControl = train_control)
print(floodModel_cv)

```

In our model, cross-validation generated an accuracy of 92.5% and a Kappa statistic of 0.284. The high accuracy confirms the model's strong ability to correctly predict both inundated and non-inundated areas overall. However, the moderate Kappa indicates room for improvement in distinguishing the inundated area from the non-inundated class.

# 7. Predict Maps

## 7.1 Predict Maps for Calgary

The map displays the spatial distribution of predicted flood risk in Calgary, generated by applying the trained logistic regression model to the entire Calgary fishnet dataset.

```{r}
fishnet_cal$calgaryPredictions <- predict(floodModel, 
                                          newdata = fishnet_cal %>% 
                                            as.data.frame() %>%
                                            dplyr::select(Nor_Elevation, Dis_River, Slope, Nor_Flow_accu,
                                                          Developed, Forest, Grassland),
                                          type = "response") * 100

fishnet_cal$risk_quantile <- ntile(fishnet_cal$calgaryPredictions, 5)
fishnet_cal <- fishnet_cal %>%
  mutate(risk_label = case_when(
    risk_quantile == 1 ~ "Very Low",
    risk_quantile == 2 ~ "Low",
    risk_quantile == 3 ~ "Moderate",
    risk_quantile == 4 ~ "High",
    risk_quantile == 5 ~ "Very High"
  ))
ggplot() + 
  geom_sf(data = fishnet_cal, aes(fill = risk_label), colour = NA) +
  scale_fill_manual(
    values = c("Very Low" = "#edf8fb",
               "Low" = "#b3cde3",
               "Moderate" = "#8c96c6",
               "High" = "#8856a7",
               "Very High" = "#810f7c"),
    name = "Flood Risk (Quantile-Based)"
  ) +
  theme_void() +
  labs(
    title = "Predicted Flood Inundation Risk in Calgary",
  ) +
  theme(legend.position = "bottom")
```

### 7.1.1 Comparison of Observed and Predicted Inundation in Calgary (OPTIONAL)

The maps provide a visual comparison between the observed 2013 flood inundation in Calgary (left) and the model-predicted high and very high flood risk zones (right). The observed map shows actual flooded areas during the 2013 event, while the prediction map highlights zones the model identified as most at risk.

```{r}
calgary_highrisk <- fishnet_cal %>%
  filter(risk_label %in% c("High", "Very High"))

# Actual 2013 Inundation Map
map_actual <- ggplot() +
  geom_sf(data = fishnet_cal, aes(fill = as.factor(inundated_binary)), color = NA) +
  scale_fill_manual(
    values = c("0" = "#f0f0f0", "1" = "#762a83"),
    labels = c("Not Inundated", "Inundated"),
    name = "2013 Event"
  ) +
  theme_void() +
  labs(title = "Observed 2013 Inundation") +
  theme(legend.position = "bottom")

# Predicted High & Very High Risk Zones Map
map_highrisk <- ggplot() +
  geom_sf(data = calgary_highrisk, aes(fill = risk_label), color = NA) +
  geom_sf(data = city_boundary_cal, fill = NA, color = "black", size = 0.5) +
  scale_fill_manual(
    values = c("High" = "#8856a7", "Very High" = "#810f7c"),
    name = "Prediction"
  ) +
  theme_void() +
  labs(title = "Predicted High Risk Inundation") +
  theme(legend.position = "bottom")
map_actual + map_highrisk
```

Overall, the predicted high-risk areas align well with many of the observed inundated zones, especially along the rivers. This suggests that our model effectively captured key flood-prone regions. However, the predicted map also includes broader areas marked as high risk, especially in the southern and eastern areas, where observed inundation did not occur.

### 7.2 Predict Maps for Portland

This map presents the predicted flood inundation risk in Portland, derived by applying the logistic regression model trained on Calgary's 2013 flood data. The predicted probabilities were scaled and categorized into five quantile-based risk levels: Very Low, Low, Moderate, High, and Very High.

```{r}
fishnet_por$portlandPredictions <- predict(floodModel, 
                                           newdata = fishnet_por %>% 
                                             as.data.frame() %>% 
                                             dplyr::select(Nor_Elevation, Dis_River, Slope, Nor_Flow_accu, Developed, Forest, Grassland), 
                                           type = "response") * 100

fishnet_por$risk_quantile <- ntile(fishnet_por$portlandPredictions, 5)

fishnet_por <- fishnet_por %>%
  mutate(risk_label = case_when(
    risk_quantile == 1 ~ "Very Low",
    risk_quantile == 2 ~ "Low",
    risk_quantile == 3 ~ "Moderate",
    risk_quantile == 4 ~ "High",
    risk_quantile == 5 ~ "Very High"
  ))

ggplot() + 
  geom_sf(data = fishnet_por, aes(fill = risk_label), colour = NA) +
  scale_fill_manual(
    values = c("Very Low" = "#edf8fb",
               "Low" = "#b3cde3",
               "Moderate" = "#8c96c6",
               "High" = "#8856a7",
               "Very High" = "#810f7c"),
    name = "Flood Risk (Quantile-Based)"
  ) +
  theme_void() +
  labs(
    title = "Predicted Flood Inundation Risk in Portland",
  ) +
  theme(legend.position = "bottom")
```

# 8. Summary

The Calgary-Portland inundation prediction model uses logistic regression to estimate flood inundation risk based on key environmental and spatial predictors, including elevation, slope, distance to river, flow accumulation, and land cover. The model was trained on Calgary’s 2013 flood data, then validated and applied to both Calgary and Portland.\

The model showed strong overall performance, with an accuracy of 91.47% on the test data and an AUC score of 0.8059, indicating good discriminatory power. The confusion matrix analysis revealed a trade-off between sensitivity (44.34%) and specificity (96.03%), reflecting the model’s greater strength in identifying non-flooded areas than inundated areas. The model is more uncertain in distinguishing flooded zones — an important consideration when prioritizing areas for flood inundation mitigation and preparation.\

When applied to Portland, the model generated a flood risk map, successfully transferring Calgary-trained insights to a different city. The prediction map identified flood-prone areas aligned with low-lying regions and rivers in Portland. This demonstrates the practical value of spatial logistic regression in urban flood risk planning, especially when inundation data may be limited in the target region.\

Overall, the model provides a useful, interpretative, and transferable tool for flood inundation probability prediction, especially in cities with similar environmental and urban characteristics. Future study may include incorporating temporal rainfall data and more localized ground data to better detect inundation risk and support urban planning efforts.


















